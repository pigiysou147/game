import { Body, BodyEvent } from './Body';

enum AxisType {
    Null,
    X,
    Y,
    Z
}

export enum SortType {
    Auto,
    XAxis,
    YAxis,
    ZAxis
}

export class SAP<T = unknown> {
    private static sortXAxis(a: Body, b: Body): number {
        return a.xMin - b.xMin;
    }
    private static sortYAxis(a: Body, b: Body): number {
        return a.yMin - b.yMin;
    }
    private static sortZAxis(a: Body, b: Body): number {
        return a.zMin - b.zMin;
    }

    /**
     * 将多个SAP实例进行组合碰撞检测
     * @param sapArr SAP实例数组
     * @param callback 碰撞回调
     * @param target 碰撞回调的this
     * 
     * @description 可以将动态和静态碰撞体分别存储在不同的SAP实例中，然后进行组合碰撞检测，可提升性能
     */
    public static trigger(sapArr: SAP[], callback: (a: Body, b: Body) => any, target?: unknown) {
        let varianceX = 0;
        let varianceY = 0;
        let varianceZ = 0;
        let axis = AxisType.Null;
        const bodies: Body[] = [];

        sapArr.forEach(sap => {
            sap.build();
            varianceX += sap.varianceX;
            varianceY += sap.varianceY;
            varianceZ += sap.varianceZ;
            Array.prototype.push.apply(bodies, sap.bodies);
        });

        if (varianceY >= varianceX && varianceY >= varianceZ) {
            axis = AxisType.Y;
            bodies.sort(this.sortYAxis);
        } else if (varianceX >= varianceY && varianceX >= varianceZ) {
            axis = AxisType.X;
            bodies.sort(this.sortXAxis);
        } else {
            axis = AxisType.Z;
            bodies.sort(this.sortZAxis);
        }

        const length = bodies.length;
        if (axis === AxisType.Y) {
            for (let index = 0; index < length; index++) {
                const bodyA = bodies[index];
                for (let i = index + 1; i < length; i++) {
                    const bodyB = bodies[i];
                    if (bodyB.yMin > bodyA.yMax) break;
                    if (bodyA.intersect(bodyB))
                        callback.call(target, bodyA, bodyB);
                }
            }
        } else if (axis === AxisType.X) {
            for (let index = 0; index < length; index++) {
                const bodyA = bodies[index];
                for (let i = index + 1; i < length; i++) {
                    const bodyB = bodies[i];
                    if (bodyB.xMin > bodyA.xMax) break;
                    if (bodyA.intersect(bodyB))
                        callback.call(target, bodyA, bodyB);
                }
            }
        } else {
            for (let index = 0; index < length; index++) {
                const bodyA = bodies[index];
                for (let i = index + 1; i < length; i++) {
                    const bodyB = bodies[i];
                    if (bodyB.zMin > bodyA.zMax) break;
                    if (bodyA.intersect(bodyB))
                        callback.call(target, bodyA, bodyB);
                }
            }
        }
    }

    private sort: SortType = SortType.Auto;
    private axis: AxisType = AxisType.Null;
    private varianceX = 0;
    private varianceY = 0;
    private varianceZ = 0;

    private dirty = false;
    private bodies: Body<T>[] = [];

    /**
     * @param sort 轴排序类型，默认自动检测
     */
    constructor(sort: SortType = SortType.Auto) {
        this.sort = sort;
        if (sort == SortType.XAxis) {
            this.axis = AxisType.X;
            this.varianceX = 1;
        } else if (sort == SortType.YAxis) {
            this.axis = AxisType.Y;
            this.varianceY = 1;
        } else if (sort == SortType.ZAxis) {
            this.axis = AxisType.Z;
            this.varianceZ = 1;
        }
    }

    /**
     * 插入一个碰撞体
     * @param body 碰撞体
     */
    insert(body: Body<T>) {
        this.bodies.push(body);
        Body.on(body, BodyEvent.AABB_CHANGED, this.refresh, this);
        this.dirty = true;
        return body.id;
    }

    /**
     * 移除一个碰撞体
     */
    remove(id: number): boolean;
    /**
     * 移除一个碰撞体
     */
    remove(body: Body): boolean;
    remove(data: number | Body) {
        const id = typeof data === 'number' ? data : data.id;
        const index = this.bodies.findIndex(body => body.id === id);
        if (index === -1) return false;

        const bodies = this.bodies.splice(index, 1);
        Body.off(bodies[0], BodyEvent.AABB_CHANGED, this.refresh, this);
        this.dirty = true;
        return true;
    }

    private refresh() {
        this.dirty = true;
    }

    private preBuild() {
        if (!this.dirty) return false;
        this.dirty = false;

        if (this.sort === SortType.Auto) {
            let totX = 0;
            let totY = 0;
            let totZ = 0;
            let totX2 = 0;
            let totY2 = 0;
            let totZ2 = 0;
            const aabbs = this.bodies;
            aabbs.forEach(aabb => {
                totX += aabb.xMid;
                totY += aabb.yMid;
                totZ += aabb.zMid;
                totX2 += aabb.xMid * aabb.xMid;
                totY2 += aabb.yMid * aabb.yMid;
                totZ2 += aabb.zMid * aabb.zMid;
            });

            const s = 1 / aabbs.length;
            const meanX = totX * s;
            const meanY = totY * s;
            const meanZ = totZ * s;
            const varianceX = this.varianceX = totX2 * s - meanX * meanX;
            const varianceY = this.varianceY = totY2 * s - meanY * meanY;
            const varianceZ = this.varianceZ = totZ2 * s - meanZ * meanZ;

            // 比较方差，选择方差较大的轴进行排序
            if (varianceY >= varianceX && varianceY >= varianceZ) {
                this.axis = AxisType.Y;
            } else if (varianceX >= varianceY && varianceX >= varianceZ) {
                this.axis = AxisType.X;
            } else {
                this.axis = AxisType.Z;
            }
        }

        return true;
    }

    private build() {
        if (this.preBuild()) {
            this.bodies.sort(this.axis === AxisType.Y
                ? SAP.sortYAxis
                : (this.axis === AxisType.X
                    ? SAP.sortXAxis
                    : SAP.sortZAxis
                )
            );
        }

        return this.axis;
    }

    private findBodyIndex(body: Body) {
        if (this.bodies.length <= 1) {
            return 0;
        }

        if (this.axis === AxisType.Y) {
            if (body.yMin <= this.bodies[0].yMin) {
                return 0;
            }
            if (this.bodies.length > 5) {
                const arr = this.bodies;
                let left = 0;
                let right = arr.length - 1;

                while (left <= right) {
                    const mid = Math.floor((left + right) / 2);
                    const body_ = arr[mid];
                    if (body.yMin >= body_.yMin && body.yMin <= body_.yMax) {
                        return mid; // 找到目标，返回索引
                    } else if (body.yMin >= body_.yMin) {
                        left = mid + 1; // 在右半区继续查找
                    } else {
                        right = mid - 1; // 在左半区继续查找
                    }
                }
                return 0;
            }
            return this.bodies.findIndex(body_ => body.yMin >= body_.yMin);
        }

        if (this.axis === AxisType.X) {
            if (body.xMin <= this.bodies[0].xMin) {
                return 0;
            }
            if (this.bodies.length > 5) {
                const arr = this.bodies;
                let left = 0;
                let right = arr.length - 1;

                while (left <= right) {
                    const mid = Math.floor((left + right) / 2);
                    const body_ = arr[mid];
                    if (body.xMin >= body_.xMin && body.xMin <= body_.xMax) {
                        return mid; // 找到目标，返回索引
                    } else if (body.xMin >= body_.xMin) {
                        left = mid + 1; // 在右半区继续查找
                    } else {
                        right = mid - 1; // 在左半区继续查找
                    }
                }
                return 0;
            }
            return this.bodies.findIndex(body_ => body.xMin >= body_.xMin);
        }

        if (body.zMin <= this.bodies[0].zMin) {
            return 0;
        }
        if (this.bodies.length > 5) {
            const arr = this.bodies;
            let left = 0;
            let right = arr.length - 1;

            while (left <= right) {
                const mid = Math.floor((left + right) / 2);
                const body_ = arr[mid];
                if (body.zMin >= body_.zMin && body.zMin <= body_.zMax) {
                    return mid; // 找到目标，返回索引
                } else if (body.zMin >= body_.zMin) {
                    left = mid + 1; // 在右半区继续查找
                } else {
                    right = mid - 1; // 在左半区继续查找
                }
            }
            return 0;
        }
        return this.bodies.findIndex(body_ => body.zMin >= body_.zMin);
    }

    private check_(axis: AxisType, index: number, bodyA: Body, contain: boolean) {
        const n = contain ? 0 : 1;
        if (axis === AxisType.Y) {
            for (let i = index + n; i < this.bodies.length; i++) {
                const bodyB = this.bodies[i];
                if (bodyB.yMin > bodyA.yMax) break;
                if (bodyA.intersect(bodyB)) return true;
            }
            for (let i = index - 1; i >= 0; i--) {
                const bodyB = this.bodies[i];
                if (bodyB.yMax < bodyA.yMin) break;
                if (bodyA.intersect(bodyB)) return true;
            }
        } else if (axis === AxisType.X) {
            for (let i = index + n; i < this.bodies.length; i++) {
                const bodyB = this.bodies[i];
                if (bodyB.xMin > bodyA.xMax) break;
                if (bodyA.intersect(bodyB)) return true;
            }
            for (let i = index - 1; i >= 0; i--) {
                const bodyB = this.bodies[i];
                if (bodyB.xMax < bodyA.xMin) break;
                if (bodyA.intersect(bodyB)) return true;
            }
        } else {
            for (let i = index + n; i < this.bodies.length; i++) {
                const bodyB = this.bodies[i];
                if (bodyB.zMin > bodyA.zMax) break;
                if (bodyA.intersect(bodyB)) return true;
            }
            for (let i = index - 1; i >= 0; i--) {
                const bodyB = this.bodies[i];
                if (bodyB.zMax < bodyA.zMin) break;
                if (bodyA.intersect(bodyB)) return true;
            }
        }

        return false;
    }

    /**
     * 检查某个碰撞体是否与其它至少一个碰撞体相交
     * @param id 碰撞体id
     */
    public check(id: number): boolean;
    /**
     * 检查某个碰撞体是否与其它至少一个碰撞体相交
     * @param body 碰撞体
     */
    public check(body: Body): boolean;
    public check(data: number | Body) {
        const axis = this.build();

        if (typeof data === 'number') {
            const index = this.bodies.findIndex(body => body.id === data);
            if (index === -1) return false;
            return this.check_(axis, index, this.bodies[index], false);
        } else {
            const index = this.findBodyIndex(data);
            return this.check_(axis, index, data, true);
        }
    }

    private retrieve_(out: Body<T>[], axis: AxisType, index: number, bodyA: Body, contain: boolean): Body<T>[] {
        const n = contain ? 0 : 1;
        if (axis === AxisType.Y) {
            for (let i = index + n; i < this.bodies.length; i++) {
                const bodyB = this.bodies[i];
                if (bodyB.yMin > bodyA.yMax) break;
                if (bodyA.intersect(bodyB))
                    out.push(bodyB);
            }
            for (let i = index - 1; i >= 0; i--) {
                const bodyB = this.bodies[i];
                if (bodyB.yMax < bodyA.yMin) break;
                if (bodyA.intersect(bodyB))
                    out.push(bodyB);
            }
        } else if (axis === AxisType.X) {
            for (let i = index + n; i < this.bodies.length; i++) {
                const bodyB = this.bodies[i];
                if (bodyB.xMin > bodyA.xMax) break;
                if (bodyA.intersect(bodyB))
                    out.push(bodyB);
            }
            for (let i = index - 1; i >= 0; i--) {
                const bodyB = this.bodies[i];
                if (bodyB.xMax < bodyA.xMin) break;
                if (bodyA.intersect(bodyB))
                    out.push(bodyB);
            }
        } else {
            for (let i = index + n; i < this.bodies.length; i++) {
                const bodyB = this.bodies[i];
                if (bodyB.zMin > bodyA.zMax) break;
                if (bodyA.intersect(bodyB))
                    out.push(bodyB);
            }
            for (let i = index - 1; i >= 0; i--) {
                const bodyB = this.bodies[i];
                if (bodyB.zMax < bodyA.zMin) break;
                if (bodyA.intersect(bodyB))
                    out.push(bodyB);
            }
        }

        return out;
    }

    /**
     * 检索与某个碰撞体相交的碰撞体数组
     * @param id 碰撞体id
     */
    public retrieve(id: number, out?: Body<T>[]): Body<T>[];
    /**
     * 检索与某个碰撞体相交的碰撞体数组
     * @param body 碰撞体
     */
    public retrieve(body: Body, out?: Body<T>[]): Body<T>[];
    public retrieve(data: number | Body, out: Body<T>[] = []): Body<T>[] {
        const axis = this.build();

        if (typeof data === 'number') {
            const index = this.bodies.findIndex(body => body.id === data);
            if (index === -1) return out;

            return this.retrieve_(out, axis, index, this.bodies[index], false);
        } else {
            const index = this.findBodyIndex(data);

            return this.retrieve_(out, axis, index, data, true);
        }
    }

    /**
     * 碰撞检测
     * @param callback 碰撞回调
     * @param target 碰撞回调的this
     */
    public trigger(callback: (a: Body<T>, b: Body<T>) => any, target?: unknown) {
        const axis = this.build();
        const bodies = this.bodies;
        const length = bodies.length;
        if (axis === AxisType.Y) {
            for (let index = 0; index < length; index++) {
                const bodyA = bodies[index];
                for (let i = index + 1; i < length; i++) {
                    const bodyB = bodies[i];
                    if (bodyB.yMin > bodyA.yMax) break;
                    if (bodyA.intersect(bodyB))
                        callback.call(target, bodyA, bodyB);
                }
            }
        } else if (axis === AxisType.X) {
            for (let index = 0; index < length; index++) {
                const bodyA = bodies[index];
                for (let i = index + 1; i < length; i++) {
                    const bodyB = bodies[i];
                    if (bodyB.xMin > bodyA.xMax) break;
                    if (bodyA.intersect(bodyB))
                        callback.call(target, bodyA, bodyB);
                }
            }
        } else {
            for (let index = 0; index < length; index++) {
                const bodyA = bodies[index];
                for (let i = index + 1; i < length; i++) {
                    const bodyB = bodies[i];
                    if (bodyB.zMin > bodyA.zMax) break;
                    if (bodyA.intersect(bodyB))
                        callback.call(target, bodyA, bodyB);
                }
            }
        }
    }

    /**
     * 清理
     */
    public clear() {
        this.dirty = false;
        this.bodies.length = 0;
        this.sort = SortType.Auto;
        this.axis = AxisType.Null;
    }
}