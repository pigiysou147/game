import { Rect } from 'cc';
import { Body, BodyEvent, IAABB, IBox } from './Body';

/**
 * 每个象限的flag
 */
const QuadFlag = [1 << 0, 1 << 1, 1 << 2, 1 << 3];
/**
 * 混合象限的flag
 * [1象限+2象限, 2象限+3象限, 3象限+4象限, 4象限+1象限]
 */
// const MixQuadFlag = [QuadFlag[0] | QuadFlag[1], QuadFlag[1] | QuadFlag[2], QuadFlag[2] | QuadFlag[3], QuadFlag[0] | QuadFlag[3]];

class QuadBody extends Body {
    static createWithRect(rect: Rect) {
        const body = new QuadBody();
        body.setRect(rect);
        return body;
    }

    static createWithAABB(aabb: IAABB) {
        const body = new QuadBody();
        body.setAABB(aabb);
        return body;
    }

    static createWithBox(box: IBox) {
        const body = new QuadBody();
        body.setBox(box);
        return body;
    }

    protected constructor() {
        super();
    }

    /**
     * 测试是否包含
     */
    contain(other: Body) {
        return this.xMin <= other.xMin &&
            this.xMax >= other.xMax &&
            this.yMin <= other.yMin &&
            this.yMax >= other.yMax;
    }

    split() {
        const xMid = this.xMid;
        const yMid = this.yMid;

        const xMin = this.xMin;
        const yMin = this.yMin;

        const xMax = this.xMax;
        const yMax = this.yMax;

        return [
            QuadBody.createWithAABB({ min: { x: xMid, y: yMid }, max: { x: xMax, y: yMax } }),
            QuadBody.createWithAABB({ min: { x: xMin, y: yMid }, max: { x: xMid, y: yMax } }),
            QuadBody.createWithAABB({ min: { x: xMin, y: yMin }, max: { x: xMid, y: yMid } }),
            QuadBody.createWithAABB({ min: { x: xMid, y: yMin }, max: { x: xMax, y: yMid } }),
        ];
    }
}

class QuadNode<T> {
    public value: Body<T> = null;
    public last: QuadNode<T> = null;
    public next: QuadNode<T> = null;

    constructor(value: Body<T>) {
        this.value = value;
    }

    public concat(next: QuadNode<T>) {
        this.next = next;
        if (next) next.last = this;
    }

    public disConcat() {
        this.last.concat(this.next);
        this.last = this.next = null;
    }
}

class QuadList<T> {
    readonly head = new QuadNode<T>(null);

    public push(node: QuadNode<T>) {
        node.concat(this.head.next);
        this.head.concat(node);
    }

    public clear() {
        this.head.next = null;
    }
}

class QuadSubTree<T> {
    protected maxLevel: number = 4;

    protected level: number = 0;
    protected quadBody: QuadBody = null;
    protected quadList: QuadList<T> = new QuadList();
    protected children: QuadSubTree<T>[] = [];
    protected parent: QuadSubTree<T> = null;

    constructor(quadBody: QuadBody, max_levels: number, level: number = 0, parent: QuadSubTree<T> = null) {
        this.level = level;
        this.quadBody = quadBody;
        this.parent = parent;
        this.maxLevel = max_levels;
    }

    /**
     * 分裂
     */
    protected split() {
        if (!this.children.length) {
            const level = this.level + 1;
            const maxLevel = this.maxLevel;
            this.quadBody.split().forEach(quadBody => {
                this.children.push(new QuadSubTree<T>(quadBody, maxLevel, level, this));
            });
        }
    }

    /**
     * 获得所在象限
     */
    protected getQuadFlags(body: Body): number {
        let flags = 0;

        const startInLeft = body.xMin < this.quadBody.xMid,
            startInTop = body.yMax > this.quadBody.yMid,
            endInRight = body.xMax > this.quadBody.xMid,
            endInBottom = body.yMin < this.quadBody.yMid;

        if (startInTop && endInRight) {
            flags |= QuadFlag[0];
        }
        if (startInTop && startInLeft) {
            flags |= QuadFlag[1];
        }
        if (startInLeft && endInBottom) {
            flags |= QuadFlag[2];
        }
        if (endInRight && endInBottom) {
            flags |= QuadFlag[3];
        }

        return flags;
    }

    /**
     * 插入
     */
    public insert(node: QuadNode<T>): QuadSubTree<T> {
        // 自身是最后一层，直接存储在自身
        if (this.level === this.maxLevel) {
            this.quadList.push(node);
            return this;
        }

        // 获取与哪些象限相交
        const quadFlags = this.getQuadFlags(node.value);
        // 子集index
        const index = QuadFlag.indexOf(quadFlags);

        // 相交数为0或多于1个，直接存储在自身
        if (index === -1) {
            this.quadList.push(node);
            return this;
        }

        // 分割子象限
        if (this.children.length === 0) {
            this.split();
        }

        // 插入到子象限中
        return this.children[index].insert(node);
    }

    /**
     * 反向插入(从子树开始向上查询)
     */
    public insertReverse(node: QuadNode<T>): QuadSubTree<T> {
        if (this.quadBody.contain(node.value)) {
            return this.insert(node);
        }
        if (this.parent) {
            return this.parent.insertReverse(node);
        }
        return this.insert(node);
    }

    /**
     * 检索(不检查子树)
     */
    private retrieveSelf(out: Body<T>[], body: Body, multiple = false) {
        if (multiple) {
            // 遍历查询
            for (let node = this.quadList.head.next, other: Body<T> = null; node; node = node.next) {
                other = node.value;
                // 排除自己
                if (body === other) continue;
                // 排除不相交
                if (!body.intersect(other)) continue;
                out.push(other);
            }
        } else {
            // 遍历查询
            for (let node = this.quadList.head.next, other: Body<T> = null; node && out.length === 0; node = node.next) {
                other = node.value;
                // 排除自己
                if (body === other) continue;
                // 排除不相交
                if (!body.intersect(other)) continue;
                out.push(other);
            }
        }
    }

    /**
     * 检索(会检查子树)
     */
    public retrieve(out: Body<T>[], body: Body, multiple = false): Body<T>[] {
        this.retrieveSelf(out, body, multiple);

        if (multiple === false && out.length > 0) {
            return out;
        }

        // 自身是最后一层，没有子节点
        if (this.level === this.maxLevel || this.children.length === 0) {
            return out;
        }

        // 获取body与哪些象限相交
        const quadFlags = this.getQuadFlags(body);
        // 组合子象限数据
        for (let index = 0; index < QuadFlag.length; index++) {
            if (!(QuadFlag[index] & quadFlags)) continue;
            this.children[index].retrieve(out, body);
            if (multiple === false && out.length > 0) break;
        }

        return out;
    }

    /**
     * 反向检索(供子树调用的内部函数)
     */
    private retrieveParent(out: Body<T>[], body: Body<T>, multiple = false): Body<T>[] {
        if (this.parent) {
            this.parent.retrieveParent(out, body, multiple);
            if (multiple === false && out.length > 0) {
                return out;
            }
        }
        this.retrieveSelf(out, body, multiple);
        return out;
    }

    /**
     * 反向检索(从子树开始向上再向下查询，可以避免不必要的向下查询)
     */
    public retrieveReverse(out: Body<T>[], body: Body<T>, multiple = false): Body<T>[] {
        if (this.parent) {
            this.parent.retrieveParent(out, body, multiple);
            if (multiple === false && out.length > 0) {
                return out;
            }
        }
        return this.retrieve(out, body, multiple);
    }

    /**
     * 清空
     */
    public clear() {
        for (let i = this.children.length - 1; i >= 0; i--) {
            this.children[i].clear();
        }

        this.quadList.clear();
        this.children.length = 0;
    }
}

export class QuadTree<T = unknown> {
    private quadTree: QuadSubTree<T> = null;

    private nodeCache: QuadNode<T>[] = [];

    private bid2Node: Map<number, QuadNode<T>> = new Map();
    private bid2Tree: Map<number, QuadSubTree<T>> = new Map();

    private createNode(body: Body<T>) {
        if (this.nodeCache.length) {
            const node = this.nodeCache.pop();
            node.value = body;
            return node;
        } else {
            return new QuadNode(body);
        }
    }

    private recycleNode(node: QuadNode<T>) {
        node.value = null;
        this.nodeCache.push(node);
    }

    /**
     * 创建
     * @param x 最小x
     * @param y 最小y
     * @param width 宽
     * @param height 高
     * @param maxLevels 最大深度(默认4)
     */
    constructor(x: number, y: number, width: number, height: number, maxLevels: number = 4) {
        const bounds = QuadBody.createWithBox({ x, y, width, height });
        this.quadTree = new QuadSubTree<T>(bounds, maxLevels);
    }

    /**
     * 插入一个碰撞体
     */
    insert(body: Body<T>) {
        const node = this.createNode(body);

        const tree = this.quadTree.insert(node);
        this.bid2Node.set(body.id, node);
        this.bid2Tree.set(body.id, tree);

        Body.on(body, BodyEvent.AABB_CHANGED, this.refresh, this);
        return body.id;
    }

    private disConcat(id: number): QuadNode<T> {
        const node = this.bid2Node.get(id);
        if (!node) return null;

        node.disConcat();
        return node;
    }

    /**
     * 移除一个碰撞体
     */
    remove(id: number): boolean;
    /**
     * 移除一个碰撞体
     */
    remove(body: Body<T>): boolean;
    remove(data: number | Body<T>) {
        const id = typeof data === 'number' ? data : data.id;
        const node = this.disConcat(id);
        if (!node) return false;

        this.bid2Node.delete(id);
        this.bid2Tree.delete(id);
        this.recycleNode(node);

        Body.off(node.value, BodyEvent.AABB_CHANGED, this.refresh, this);
        return true;
    }

    /**
     * 刷新一个碰撞体
     * @param id 
     * @param aabb 包围盒
     * @returns 
     */
    private refresh(body: Body<T>): boolean {
        const node = this.disConcat(body.id);
        if (!node) return false;

        const oldTree = this.bid2Tree.get(body.id);
        const newTree = oldTree.insertReverse(node);
        if (oldTree !== newTree) {
            this.bid2Tree.set(body.id, newTree);
        }

        return true;
    }

    /**
     * 检索与某个碰撞体相交的碰撞体数组
     * @param id 碰撞体id
     */
    public retrieve(id: number, out?: Body<T>[]): Body<T>[];
    /**
     * 检索与某个碰撞体相交的碰撞体数组
     * @param body 碰撞体
     */
    public retrieve(body: Body, out?: Body<T>[]): Body<T>[];
    public retrieve(data: number | Body, out: Body<T>[] = []): Body<T>[] {
        if (typeof data === 'number') {
            const node = this.bid2Node.get(data);
            if (!node) return out;

            const tree = this.bid2Tree.get(data);
            return tree.retrieveReverse(out, node.value, true);
        } else {
            return this.quadTree.retrieve(out, data, true);
        }
    }

    /**
     * 检查某个碰撞体是否与其它至少一个碰撞体相交
     * @param id 碰撞体id
     */
    public check(id: number): boolean;
    /**
     * 检查某个碰撞体是否与其它至少一个碰撞体相交
     * @param body 碰撞体
     */
    public check(body: Body): boolean;
    public check(data: number | Body) {
        if (typeof data === 'number') {
            const node = this.bid2Node.get(data);
            if (!node) return false;

            const tree = this.bid2Tree.get(data);
            return tree.retrieveReverse([], node.value, false).length > 0;
        } else {
            return this.quadTree.retrieve([], data, false).length > 0;
        }
    }

    /**
     * 碰撞检测
     * @param callback 碰撞回调
     */
    public trigger(callback: (a: Body<T>, b: Body<T>) => any) {
        const out: Body<T>[] = [];
        const triggered: Map<number, number> = new Map();
        this.bid2Node.forEach((node, id) => {
            out.length = 0;
            const body = node.value;
            const tree = this.bid2Tree.get(id);
            tree.retrieveReverse(out, body, true);
            out.forEach((other) => {
                if (body.id < other.id) {
                    if (triggered.get(body.id) === other.id) return;
                    triggered.set(body.id, other.id);
                } else if (body.id > other.id) {
                    if (triggered.get(other.id) === body.id) return;
                    triggered.set(other.id, body.id);
                }

                callback(body, other);
            });
        });
    }

    /**
     * 清理内存
     */
    public clear() {
        this.quadTree.clear();
        this.bid2Node.clear();
        this.bid2Tree.clear();
        this.nodeCache.length = 0;
    }
}