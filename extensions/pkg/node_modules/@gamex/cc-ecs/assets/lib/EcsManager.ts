import { DEV } from 'cc/env';
import { EcsBase, EcsBaseComponent, EcsBaseSingleton, IComponent, IComponentName, IEntity, IEntityUUID, IFlag, ISystem, ITypeofSystem } from './EcsObject';
import { CustomArray } from './EcsUtils';

/**
 * EcsComponent装饰器
 */
export function ecsclass(className: string) {
    return function fNOP(ctor: any) {
        // ecsName需要先初始化
        (<typeof EcsBase>ctor).ecsName = className;
        classManager.add(ctor, className);
        return ctor;
    };
}

/** 
 * flag位管理器
*/
class FlagManager {
    private index: number = 0;
    private cache: Map<string, IFlag> = new Map();
    private cacheAll: Map<string, IFlag> = new Map();

    /**
     * 在source中添加flag
     * @param source 
     * @param flag 
     */
    addFlag(source: IFlag, flag: IFlag) {
        for (let index = 0; index < flag.length; index++) {
            source[index] |= flag[index];
        }
    }
    /**
     * 在source中移除flag
     * @param source 
     * @param flag 
     */
    removeFlag(source: IFlag, flag: IFlag) {
        for (let index = 0; index < flag.length; index++) {
            source[index] &= ~flag[index];
        }
    }

    /**
     * 检查是否完全包含
     * @param source 源
     * @param sub 子集
     */
    checkFlagAll(source: IFlag, sub: IFlag) {
        for (let index = 0; index < sub.length; index++) {
            if ((source[index] & sub[index]) !== sub[index]) return false;
        }
        return true;
    }
    /**
     * 只包含其中一个即可
     * @param source 源
     * @param sub 子集
     */
    checkFlagAny(source: IFlag, sub: IFlag) {
        for (let index = 0; index < sub.length; index++) {
            if ((source[index] & sub[index]) != 0) return true;
        }
        return false;
    }

    /**
     * 会融合父类
     */
    getAllByName(name: string): IFlag {
        const result = this.cacheAll.get(name);
        if (result) return result;

        const names = [name];
        classManager.eachSuperName(name, (superName) => {
            names.push(superName);
        });

        const flag = this.getByNames(names);
        this.cacheAll.set(name, flag);

        return flag;
    }

    /**
     * 会融合父类
     */
    getAllByNames(names: string[], out: number[]): IFlag {
        // 设置初始值
        let flag = this.getAllByName(names[0]);
        for (let index = 0; index < out.length; index++) {
            out[index] = flag[index];
        }
        // 叠加
        for (let i = 1; i < names.length; i++) {
            flag = this.getAllByName(names[i]);
            for (let index = 0; index < out.length; index++) {
                out[index] = out[index] | flag[index];
            }
        }
        return out;
    }

    /**
     * 只计算自身
     */
    getByName(name: string): IFlag {
        const result = this.cache.get(name);
        if (result) return result;

        const FlagBits = this.bits;

        if (DEV && this.index >= FlagBits * 31) {
            throw new Error(`当前Component的种类超过${FlagBits * 31}个`);
        }

        const flag: IFlag = new Array(FlagBits).fill(0);
        flag[(this.index / 31) >>> 0] = (1 << (this.index % 31));
        this.cache.set(name, flag);
        this.index++;

        return flag;
    }

    /**
     * 只计算自身
     */
    getByNames(names: string[]): IFlag {
        const result = new Array(this.bits);
        // 设置初始值
        let flag = this.getByName(names[0]);
        for (let index = 0; index < result.length; index++) {
            result[index] = flag[index];
        }
        // 叠加
        for (let i = 1; i < names.length; i++) {
            flag = this.getByName(names[i]);
            for (let index = 0; index < result.length; index++) {
                result[index] = result[index] | flag[index];
            }
        }
        return result;
    }

    get bits() {
        return Math.ceil(classManager.comSize / 31);
    }
}
export const flagManager = new FlagManager();

/**
 * 类管理器
 */
class ClassManager {
    private comClassCount = 0;
    private nameToSuperName: Map<string, string> = new Map();
    private nameToClass: Map<string, typeof EcsBase> = new Map();
    /**
     * 获取父类
     */
    private getSuper<T extends typeof EcsBase>(type: T): T {
        if (!type || !type.prototype) return null;
        const proto = type.prototype; // binded function do not have prototype
        const dunderProto = proto && Object.getPrototypeOf(proto);
        return dunderProto && dunderProto.constructor;
    }

    add(ctor: typeof EcsBase, className: string) {
        if (DEV && this.nameToClass.has(className)) {
            console.error(`[ecs] ${className}已存在`);
        }
        this.nameToClass.set(className, ctor);

        // 存储类名继承对应关系
        let superCls = this.getSuper(ctor);
        while (superCls && superCls.ecsName !== EcsBase.ecsName) {
            if (DEV && className === superCls.ecsName) {
                console.error(`[ecs] 请使用ecsclass修饰\n @ecsclass('${ctor.name}')\n`, ctor);
                return;
            }
            this.nameToSuperName.set(className, superCls.ecsName);
            superCls = this.getSuper(ctor = superCls);
            className = ctor.ecsName;
        }

        if (superCls === EcsBaseComponent) {
            this.comClassCount++;
        } else if (DEV && superCls !== EcsBaseSingleton) {
            console.warn('[ecs] 避免用ecsclass修饰系统或实体', className);
        }
    }

    /**
     * 遍历所有父类名
     */
    eachSuperName(subName: string, callback: (superName: string) => any) {
        while (subName) {
            const superName = this.getSuperName(subName);
            if (!superName) break;
            callback(subName = superName);
        }
    }

    /**
     * 通过类名判断一个是否是另一个的子类
     * @param subName 
     * @param superName 
     * @returns 
     */
    isChildByName(subName: string, superName: string) {
        if (!subName) return false;
        if (!superName) return false;

        while (subName) {
            const _superName = this.getSuperName(subName);
            if (_superName === superName) return true;
            subName = _superName;
        }

        return false;
    }

    /**
     * 通过类名获取一个类
     * @param name 
     * @returns 
     */
    getClassByName(name: string) {
        return this.nameToClass.get(name);
    }

    /**
     * 获取父类名字
     */
    getSuperName(name: string) {
        return this.nameToSuperName.get(name) || '';
    }

    /**
     * 组件种类数量
     */
    get comSize() {
        return this.comClassCount;
    }
}
/**类管理器 */
export const classManager = new ClassManager();

/**
 * 组件管理器
 */
export class ComponentManager {
    private components: Map<IComponentName, CustomArray<IComponent>> = new Map();

    private getOrCreateComps(name: IComponentName) {
        if (!this.components.has(name)) {
            this.components.set(name, new CustomArray<IComponent>());
        }
        return this.components.get(name);
    }

    /**
     * 添加一个组件名对应的实体
     */
    addComponent(comName: IComponentName, comp: IComponent) {
        if (!comName) return;

        // 添加当前
        this.getOrCreateComps(comName).add(comp);

        // 添加基类
        this.addComponent(classManager.getSuperName(comName), comp);
    }

    /**
     * 移除一个组件名对应的实体
     */
    removeComponent(comName: IComponentName, comp: IComponent) {
        if (!comName) return;

        // 删除当前
        if (!this.components.has(comName)) return;
        this.getOrCreateComps(comName).remove(comp);

        // 删除基类
        this.removeComponent(classManager.getSuperName(comName), comp);
    }

    /**
     * 根据组件名获取实体列表，可能不存在
     */
    getComponents(comName: IComponentName) {
        return this.components.get(comName) || null;
    }

    clear() {
        this.components.forEach(value => value.clear());
        this.components.clear();
    }
}

/**
 * 实体管理器
 */
export class EntityManager {
    private entities: Map<IEntityUUID, IEntity> = new Map();

    has(uuid: IEntityUUID) {
        return this.entities.get(uuid) || null;
    }

    add(entity: IEntity) {
        this.entities.set(entity.uuid, entity);
    }

    remove(entity: IEntity) {
        return this.entities.delete(entity.uuid);
    }

    get(uuid: IEntityUUID) {
        return this.entities.get(uuid) || null;
    }

    getAll(out: IEntity[]) {
        this.entities.forEach(entity => out.push(entity));
        return out;
    }

    each(callback: (value: IEntity) => void) {
        this.entities.forEach(callback);
    }

    clear() {
        this.entities.clear();
    }
}

/**
 * 系统管理器
 */
export class SystemManager {
    private systems: ISystem[] = [];

    /**
     * 添加系统
     */
    add(system: ISystem) {
        this.systems.push(system);
    }

    get(System: ITypeofSystem) {
        const index = this.systems.findIndex(system => system.ecsName === System.ecsName);
        return this.systems[index];
    }

    /**
     * 移除系统
     */
    remove(System: ITypeofSystem) {
        const index = this.systems.findIndex(system => system.ecsName === System.ecsName);
        if (index >= 0) {
            return this.systems.splice(index, 1)[0] || null;
        }
        return null;
    }

    /**
     * 清空所有
     */
    clear() {
        this.systems.length = 0;
    }

    each(callback: (value: ISystem) => void) {
        this.systems.forEach(callback);
    }

    get size() {
        return this.systems.length;
    }
}

