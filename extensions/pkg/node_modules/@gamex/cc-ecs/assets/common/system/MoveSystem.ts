import { math } from 'cc';
import { filter } from '../../ecs';
import { EcsSystem } from '../../ecs/EcsSystem';
import { IEntity } from '../../lib/EcsObject';
import { IMoveComponent, MoveComponent, MoveTowardType } from '../component/MoveComponent';
import { NodeComponent } from '../component/NodeComponent';

/**
 * 修正为范围值
 */
function getAbsoluteValue(input: number, threshold: number) {
    if (threshold < 0) {
        threshold = -threshold;
    }
    if (input > 0) {
        if (input > threshold) return threshold;
        return input;
    }
    if (input < 0) {
        if (input < -threshold) return -threshold;
    }
    return input;
}

/**
 * 负责驱动move组件
 */
export class MoveSystem extends EcsSystem {
    private filter = filter.all(MoveComponent, NodeComponent);

    protected execute(dt?: number): void {
        this.query(this.filter, MoveComponent).forEach((move) => {
            this.handle(move, move.entity, dt);
        })
    }

    /**
     * 处理
     * @param move 
     * @param entity 
     * @param dt 
     */
    private handle(move: IMoveComponent, entity: IEntity, dt: number) {
        // 追踪角度
        if (move.target) {
            move.toward = MoveComponent.getTowardAngle(entity.getComponent(NodeComponent), move.target);
        }

        this.rotate(move, entity, dt);

        // 初速度
        const lastSpeed = move.speed;
        // 加速度
        move.speed += move.options.acceleratedVelocity * dt;
        if (move.speed < move.options.minSpeed) {
            move.speed = move.options.minSpeed;
        }
        if (move.speed > move.options.maxSpeed) {
            move.speed = move.options.maxSpeed;
        }
        // 平均速度
        const speed = (lastSpeed + move.speed) / 2;
        this.run(move, entity, dt, speed);
    }

    private run(move: IMoveComponent, entity: IEntity, dt: number, speed: number) {
        // 移动距离
        const distance = speed * dt;
        // 设置节点位移
        if (move.angle === MoveTowardType.Right) {
            entity.getComponent(NodeComponent).addPosition(distance, 0);
        } else if (move.angle === MoveTowardType.Left) {
            entity.getComponent(NodeComponent).addPosition(-distance, 0);
        } else if (move.angle === MoveTowardType.Up) {
            entity.getComponent(NodeComponent).addPosition(0, distance);
        } else if (move.angle === MoveTowardType.Down) {
            entity.getComponent(NodeComponent).addPosition(0, -distance);
        } else {
            // 会有细微的误差
            const radian = math.toRadian(move.angle);
            const x = Math.cos(radian) * distance;
            const y = Math.sin(radian) * distance;
            entity.getComponent(NodeComponent).addPosition(x, y);
        }
        // 记录移动
        move.distance += distance;
    }

    private rotate(move: IMoveComponent, entity: IEntity, dt: number) {
        let addAngle = 0;
        if (move.toward !== move.angle) {
            // 角度差值
            const diffAngle = MoveComponent.getAngleFromNeg180to180(move.toward - move.angle);
            // 差值限制(实际增加)
            addAngle = move.options.angleVelocity === 0 ? diffAngle : getAbsoluteValue(diffAngle, move.options.angleVelocity * dt);
            // 实际角度
            move.angle += addAngle;

            // 设置节点角度
            if (move.options.rotate) {
                entity.getComponent(NodeComponent).setAngle(move.angle);
            }
        }

        return addAngle;
    }
}

